# -*- coding: utf-8 -*-

# Author: Annie Dequit
#
# Created by: PyQt5 UI 
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os,sys,re
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QStringListModel, Qt
from PyQt5.QtWidgets import (QMainWindow, QAction, QMenuBar, 
QMessageBox, QProgressBar,QMenu)

# from PySide2extn.RoundProgressBar import roundProgressBar

from PyQt5.QtGui import QFont
from DirectoryModel import DirProxyModel, PandasModel
from uiStructure import Ui_mainWindow
import warnings
import sqlite3


from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
from matplotlib.figure import Figure
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from plotly.figure_factory import create_distplot
from sklearn.metrics import classification_report, balanced_accuracy_score

warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt
from matplotlib.axes import Subplot as plt

import math
import seaborn as sns
sns.set()
# from PIL import Image
import PIL.Image
import torch
import torch.nn as nn

#torch.optim is a package implementing various optimization algorithms
import torch.optim as optim

# from torch.optim.lr_scheduler import ReduceLROnPlateau, StepLR, CyclicLrR
import torchvision
from torchvision import datasets, models, transforms
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F

from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.utils.class_weight import compute_class_weight

from glob import glob
from skimage.io import imread
from os import listdir

import time
import copy
from tqdm import tqdm_notebook as tqdm
 
from plotly.graph_objs import *
import plotly.express as px

run_training = False
retrain = False
find_learning_rate = False


#================================================================================
class BreastCancerDataset(Dataset):      
    def __init__(self, df, transform=None):
        self.states = df
        self.transform=transform
      
    def __len__(self):
        return len(self.states)
        
    def __getitem__(self, idx):
        patient_id = self.states.patient_id.values[idx]
        x_coord = self.states.x.values[idx]
        y_coord = self.states.y.values[idx]
        image_path = self.states.path.values[idx] 
        image = Image.open(image_path)
        image = image.convert('RGB')
        
        if self.transform:
            image = self.transform(image)
        
        if "target" in self.states.columns.values:
            target = np.int(self.states.target.values[idx])
        else:
            target = None
            
        return {"image": image,
                "label": target,
                "patient_id": patient_id,
                "x": x_coord,
                "y": y_coord}



#================================================================================

class MplWidget(QtWidgets.QWidget):
    send_fig = QtCore.pyqtSignal(str)
  
    def __init__(self, parent=None, f1=15, f2=8, sp1=1, sp2=2):
        
        super().__init__(parent)
        
        # figsize=(10,5)
        self.figure = Figure(figsize=(f1,f2))
        self.canvas = FigureCanvasQTAgg(self.figure)
        self.toolbar = NavigationToolbar2QT(self.canvas, self)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        # subplots = (1,2)
        self.ax = self.canvas.figure.subplots(sp1,sp2)


#==============================================================================
class Main(QtWidgets.QMainWindow, Ui_mainWindow):
    # send_fig = QtCore.pyqtSignal(str)

    def __init__(self):
        QtWidgets.QMainWindow.__init__(self)
        self.setupUi(self)

        self.base_path= "breast-histopathology-images/IDC_regular_ps50_idx5/"
        self.folders_list = listdir(self.base_path)

#*******************************************************************************
#Target distributions 
        patients = self.df.patient_id.unique()
        data=self.df  #this is our main source of path dataframe (self.df) was declared from the other class. It is the dataframe of
                     # all the path of microscopic images from each patient

        train_ids, sub_test_ids = train_test_split(patients,test_size=0.3,random_state=0)
        test_ids, dev_ids = train_test_split(sub_test_ids, test_size=0.5, random_state=0)

        train_df = data.loc[data.patient_id.isin(train_ids),:].copy()  #here we used the data variable declared above $ make a copy
        test_df = data.loc[data.patient_id.isin(test_ids),:].copy()
        dev_df = data.loc[data.patient_id.isin(dev_ids),:].copy()

        self.train_df = self.extract_coords(train_df)    #to get the x and y coordinates of the tissue images dimensions
        self.test_df = self.extract_coords(test_df)      #extract
        self.dev_df = self.extract_coords(dev_df)

#*********************************************************************************************
 #to create a dataset that loads an image patch of a patient, converts it to RGB, 
 # performs the augmentation if it's desired and returns the image, the target, the patient id and the image coordinates.      
        self.train_dataset = BreastCancerDataset(self.train_df, transform=self.my_transform(key="train"))
        self.dev_dataset = BreastCancerDataset(self.dev_df, transform=self.my_transform(key="val"))
        self.test_dataset = BreastCancerDataset(self.test_df, transform=self.my_transform(key="val"))

        image_datasets = {"train": self.train_dataset, "dev": self.dev_dataset, "test": self.test_dataset}
        self.dataset_sizes = {x: len(image_datasets[x]) for x in ["train", "dev", "test"]}

#==============================================================================
# Machine Learning Modeling  **************************************************
#==============================================================================
#Setting up Machine Learning workflow
        BATCH_SIZE = 32
        self.NUM_CLASSES = 2 # Number of classes in the dataset
        self.OUTPUT_PATH = ""
        self.MODEL_PATH = "breastcancermodel/"
        self.LOSSES_PATH = "breastcancermodel/"
        torch.manual_seed(0)
        np.random.seed(0)

#******************************************************************************************
# Creating pytorch dataloaders
        self.train_dataloader = DataLoader(self.train_dataset, batch_size=BATCH_SIZE, shuffle=True, drop_last=True)
        self.dev_dataloader = DataLoader(self.dev_dataset, batch_size=BATCH_SIZE, shuffle=False, drop_last=True)
        self.test_dataloader = DataLoader(self.test_dataset, batch_size=BATCH_SIZE, shuffle=False, drop_last=False)
        self.dataloaders = {"train": self.train_dataloader, "dev": self.dev_dataloader, "test": self.test_dataloader}

#==========================================================================
 #Defining the CNN model structure 
 #*******************************************************************
        self.device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
        print(self.device)

        self.model = self.SettingCNNFilter_Function()

        weights = compute_class_weight(y=self.train_df.target.values, class_weight="balanced", classes=self.train_df.target.unique())    
        self.class_weights = torch.FloatTensor(weights)
        self.criterion = nn.CrossEntropyLoss(weight=self.class_weights)

    
    def init_weights(self,m):
        if type(m) == nn.Linear:
                torch.nn.init.xavier_uniform_(m.weight)
                m.bias.data.fill_(0.01)
#----------------------------------------------------------------------------------
#  first layers of a pretrained CNN extract basic features like edges for example 
#  and only last layers contain very problem specific features.
#-------------------------------------------------------------------
#Goal is to start simple CNN layer by using a small network like resnet18:

# ResNet-18 (Residual Networks) is a convolutional neural network that is 18 layers deep.
#  You can load a pretrained version of the network trained on more than a
#  million images from the ImageNet database
#=================================================================================
    def SettingCNNFilter_Function(self):
          print("setting CNNFilter...")

          model = torchvision.models.resnet18(pretrained=False) #Model chosen
          if run_training:
                model.load_state_dict(torch.load("../input/pretrained-pytorch-models/resnet18-5c106cde.pth"))
          num_features = model.fc.in_features
          print(num_features)

          ## this is the 3 layers of the Convolutional Neural Network (CNN)
          model.fc = nn.Sequential(
                nn.Linear(num_features, 512),
                nn.ReLU(),
                nn.BatchNorm1d(512),
                nn.Dropout(0.5),
                
                nn.Linear(512, 256),
                nn.ReLU(),
                nn.BatchNorm1d(256),
                nn.Dropout(0.5),
                
                nn.Linear(256, self.NUM_CLASSES))

          
          model.apply(self.init_weights)
          model = model.to(self.device)

          return model

        
    #Setting up the loss function--------------------------
    #using the cross entropy loss with K=2 output neurons or 2 classes that can be hot (1) or cold (0) with  âˆ‘ð‘˜ð‘¦ð‘›ð‘˜=1 :
    #to weight the positive and negative classes such that we are able to deal with the class imbalance.

          if self.device.type=="cuda":
             class_weights = self.class_weights.cuda()
          print("You can see that class 1 (positive cancer) has a higher weight." + class_weights)
          
    #Selecting an evaluation metric--------------------------------------------------
    #--------------------------------------------------------------------------------
    # ð‘“1=  2 / ((1/ð‘Ÿð‘’ð‘ð‘Žð‘™ð‘™)+(1/ð‘ð‘Ÿð‘’ð‘ð‘–ð‘ ð‘–ð‘œð‘›))
    # f1-score is a measure of a model's accuracy on a dataset.
    
    #Precision and recall
    # ð‘Ÿð‘’ð‘ð‘Žð‘™ð‘™= (ð‘‡ð‘Ÿð‘¢ð‘’ð‘ƒð‘œð‘ ð‘–ð‘¡ð‘–ð‘£ð‘’ð‘  / (ð‘‡ð‘Ÿð‘¢ð‘’ð‘ƒð‘œð‘ ð‘–ð‘¡ð‘–ð‘£ð‘’ð‘  + ð¹ð‘Žð‘™ð‘ ð‘’ð‘ƒð‘œð‘ ð‘–ð‘¡ð‘–ð‘£ð‘’ð‘ )
    # ð‘ð‘Ÿð‘’ð‘ð‘–ð‘ ð‘–ð‘œð‘›=  (ð‘‡ð‘Ÿð‘¢ð‘’ð‘ƒð‘œð‘ ð‘–ð‘¡ð‘–ð‘£ð‘’ð‘   /  (ð‘‡ð‘Ÿð‘¢ð‘’ð‘ƒð‘œð‘ ð‘–ð‘¡ð‘–ð‘£ð‘’ð‘  + ð¹ð‘Žð‘™ð‘ ð‘’ð‘ð‘’ð‘”ð‘Žð‘¡ð‘–ð‘£ð‘’ð‘ )
     

    def f1_score(preds, targets):
        
        tp = (preds*targets).sum().to(torch.float32)
        fp = ((1-targets)*preds).sum().to(torch.float32)
        fn = (targets*(1-preds)).sum().to(torch.float32)
        
        epsilon = 1e-7
        precision = tp / (tp + fp + epsilon)
        recall = tp / (tp + fn + epsilon)
        
        f1_score = 2 * precision * recall/(precision + recall + epsilon)
        return f1_score

#==============================================================
#Building the training loop 
#---------------------------------------------------------------
    def train_loop(self, model, criterion, optimizer, lr_find=False, scheduler=None, num_epochs = 3, lam=0.0):
        since = time.time()
        if lr_find:
            phases = ["train"]
        else:
            phases = ["train", "dev", "test"]
        
        best_model_wts = copy.deepcopy(model.state_dict())
        best_acc = 0.0
        
        loss_dict = {"train": [], "dev": [], "test": []}
        lam_tensor = torch.tensor(lam, device=self.device)
        
        running_loss_dict = {"train": [], "dev": [], "test": []}
        
        lr_find_loss = []
        lr_find_lr = []
        smoothing = 0.2
        
        for epoch in range(num_epochs):
            print('Epoch {}/{}'.format(epoch, num_epochs - 1))
            print('-' * 10)
            
            for phase in phases:
                if phase == "train":
                    model.train()
                else:
                    model.eval()

                running_loss = 0.0
                running_corrects = 0
                
                tk0 = tqdm(self.dataloaders[phase], total=int(len(self.dataloaders[phase])))

                counter = 0
                for bi, d in enumerate(tk0):
                    inputs = d["image"]
                    labels = d["label"]
                    inputs = inputs.to(self.device, dtype=torch.float)
                    labels = labels.to(self.device, dtype=torch.long)
                    
                    # zero the parameter gradients
                    optimizer.zero_grad()
                    
                    # forward
                    # track history if only in train
                    
                    with torch.set_grad_enabled(phase == 'train'):
                        outputs = model(inputs)
                        _, preds = torch.max(outputs, 1)
                        loss = criterion(outputs, labels)
                    
                        # backward + optimize only if in training phase
                        if phase == 'train':
                            loss.backward()
                            
                            #l2_reg = torch.tensor(0., device=device)
                            #for param in model.parameters():
                                #l2_reg = lam_tensor * torch.norm(param)
                            
                            #loss += l2_reg
                
                            optimizer.step()
                            # cyclical lr schedule is invoked after each batch
                            if scheduler is not None:
                                scheduler.step() 
                                if lr_find:
                                    lr_step = optimizer.state_dict()["param_groups"][0]["lr"]
                                    lr_find_lr.append(lr_step)
                                    if counter==0:
                                        lr_find_loss.append(loss.item())
                                    else:
                                        smoothed_loss = smoothing  * loss.item() + (1 - smoothing) * lr_find_loss[-1]
                                        lr_find_loss.append(smoothed_loss)
                                
                    # statistics
                    running_loss += loss.item() * inputs.size(0)
                    running_corrects += torch.sum(preds == labels.data)                      
        
                    counter += 1
                    
                    
                    tk0.set_postfix({'loss': running_loss / (counter * self.dataloaders[phase].batch_size),
                                    'accuracy': running_corrects.double() / (counter * self.dataloaders[phase].batch_size)})
                    running_loss_dict[phase].append(running_loss / (counter * self.dataloaders[phase].batch_size))
                    
                epoch_loss = running_loss / self.dataset_sizes[phase]
                loss_dict[phase].append(epoch_loss)
                epoch_acc = running_corrects.double() / self.dataset_sizes[phase]
                print('{} Loss: {:.4f} Acc: {:.4f}'.format(
                    phase, epoch_loss, epoch_acc))
                
                # deep copy the model
                if phase == 'dev' and epoch_acc > best_acc:
                    best_acc = epoch_acc
                    best_model_wts = copy.deepcopy(model.state_dict())
            print()
            
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
        time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))              
        
        # load best model weights
        model.load_state_dict(best_model_wts)
        results = {"model": model,
                "loss_dict": loss_dict,
                "running_loss_dict": running_loss_dict,
                "lr_find": {"lr": lr_find_lr, "loss": lr_find_loss}}
        return results

#=========================================================================
    def applyCNNFilter_Function(self):
        self.hideWidgets()
        print("applying CNNFilter")

        self.middleLabel.setGeometry(QtCore.QRect(432, 165, 371, 171))
        self.labelWithPhoto.setVisible(True)
        self.middleLabel.setVisible(True)
              
        self.middleLabel.setText("Applying Convolutional Neural Network Layer. . . .\n Please Wait...")
        self.SettingCNNFilter_Function()
        self.middleLabel.setText("Applying Convolutional Neural Network Layer . . . .")
        self.middleLabel.setText("Done! You may proceed . . . .")



#=================================================================================
#Searching for an optimal cyclical learning rate 

    def searchingOptimalCyclical_HIGH_lr_Function(self):
        self.hideWidgets()
        print("Searching for an optimal cyclical learning rate, \nusing  start_lr = 1e-6\nend_lr = 0.1 ")

        #setting up value for model's learning rate(start-end)
        start_lr = 1e-6
        end_lr = 0.1

        if find_learning_rate:
            lr_find_epochs=1
            optimizer = optim.SGD(self.model.fc.parameters(), start_lr)
            scheduler = self.get_lr_search_scheduler(optimizer, start_lr, end_lr, lr_find_epochs*len(self.train_dataloader))
            results = self.train_loop(self.model, self.criterion, optimizer, lr_find=True, scheduler=scheduler, num_epochs=lr_find_epochs)
            lr_find_lr, lr_find_loss = results["lr_find"]["lr"], results["lr_find"]["loss"]
            
            find_lr_df = pd.DataFrame(lr_find_loss, columns=["smoothed loss"])
            find_lr_df.loc[:, "lr"] = lr_find_lr
            find_lr_df.to_csv("learning_rate_search.csv", index=False)
        else:
            find_lr_df = pd.read_csv(self.MODEL_PATH + "learning_rate_search.csv")
        
        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)
    
        # #=====================================================
        # #making subplots
        fig = make_subplots(rows=2, cols=2,   vertical_spacing = 0.10,   horizontal_spacing = 0.10,subplot_titles=('<b>How the learning rate increases during search','<b>How the training loss evolves during search','<b>Searching for the optimal learning rate'),
             specs=[[{"secondary_y": True}, {"secondary_y": True}],
                           [{"secondary_y": True}, {"secondary_y": True}]])
        
        # #=====================================================
        # #1st column axes
        fig.add_trace(
            go.Line(y=find_lr_df.lr.values,name='',  showlegend=False),
            row=1, col=1, secondary_y=False,
        )
            
        # #=====================================================
        # #2nd column axes

        fig.add_trace(
        go.Line(y=find_lr_df["smoothed loss"].values,name='', showlegend=False),
            row=1, col=2, secondary_y=False,
        )
        
        
        # #=====================================================
        # #3rd column axes

        fig.add_trace(          
        go.Line(x=find_lr_df.lr.values, y=find_lr_df["smoothed loss"].values,name='', showlegend=False ),
            row=2, col=1, secondary_y=False,
        )

        fig.update_xaxes(row=2, col=1,type="log",range=[-4,-1])

        fig.update_xaxes(row=1, col=1,title_text="Steps")
        fig.update_xaxes(row=1, col=2,title_text= "Steps")
        fig.update_xaxes(row=2, col=1,title_text="Learning  rate")

        fig.update_yaxes(row=1, col=1,title_text="Learning  rate")
        fig.update_yaxes(row=1, col=2,title_text="Loss")
        fig.update_yaxes(row=2, col=1,title_text="Smoothed  Loss")


        fig.update_annotations(font=dict(family="Helvetica", size=20))
        fig.update_layout( width=1400, height=850)

        self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
        self.mpl_CanvasToPlot2.resize(1390,850)



#---------------------------------------------------------------------------
    def get_lr_search_scheduler(self,optimizer, min_lr, max_lr, max_iterations):
        # max_iterations should be the number of steps within num_epochs_*epoch_iterations
        # this way the learning rate increases linearily within the period num_epochs*epoch_iterations 
        scheduler = torch.optim.lr_scheduler.CyclicLR(optimizer=optimizer, 
                                                base_lr=min_lr,
                                                max_lr=max_lr,
                                                step_size_up=max_iterations,
                                                step_size_down=max_iterations,
                                                mode="triangular")
    
        return scheduler

    def get_scheduler(self,optimiser, min_lr, max_lr, stepsize):
        # suggested_stepsize = 2*num_iterations_within_epoch
        stepsize_up = np.int(stepsize/2)
        scheduler = torch.optim.lr_scheduler.CyclicLR(optimizer=optimiser,
                                                base_lr=min_lr,
                                                max_lr=max_lr,
                                                step_size_up=stepsize_up,
                                                step_size_down=stepsize_up,
                                                mode="triangular")
        return scheduler
 
#----------------------------------------------------------------
    def searchingOptimalCyclical_LOW_lr_Function(self):
        self.hideWidgets()
        #leaning towards the minimum side of learning rate so it wont shoot pass the minimum value
        #for more accurate train model
        print("Searching for an optimal cyclical learning rate, using  start_lr = 1e-6\nend_lr = 0.006")
        start_lr = 1e-6
        end_lr = 0.006
        model = self.SettingCNNFilter_Function()
         
        if run_training:
            NUM_EPOCHS = 30
            optimizer = optim.SGD(model.fc.parameters(), lr=0.01)
            scheduler = self.get_scheduler(optimizer, start_lr, end_lr, 2*NUM_EPOCHS)
            results = self.train_loop(model, self.criterion, optimizer, scheduler=scheduler, num_epochs = NUM_EPOCHS)
            model, loss_dict, running_loss_dict = results["model"], results["loss_dict"], results["running_loss_dict"]
            
            if self.device == "cpu":
                OUTPUT_PATH += ".pth"
            else:
                OUTPUT_PATH += "_cuda.pth"
                
            torch.save(model.state_dict(), OUTPUT_PATH)
            
            losses_df = pd.DataFrame(loss_dict["train"],columns=["train"])
            losses_df.loc[:, "dev"] = loss_dict["dev"]
            losses_df.loc[:, "test"] = loss_dict["test"]
            losses_df.to_csv("losses_breastcancer.csv", index=False)
            
            running_losses_df = pd.DataFrame(running_loss_dict["train"], columns=["train"])
            running_losses_df.loc[0:len(running_loss_dict["dev"])-1, "dev"] = running_loss_dict["dev"]
            running_losses_df.loc[0:len(running_loss_dict["test"])-1, "test"] = running_loss_dict["test"]
            running_losses_df.to_csv("running_losses_breastcancer.csv", index=False)
        else:
            if self.device == "cpu":
                load_path = self.MODEL_PATH + ".pth"
            else:
                load_path = self.MODEL_PATH + "_cuda.pth"
            model.load_state_dict(torch.load(load_path, map_location='cpu'))
            model.eval()
            
            losses_df = pd.read_csv(self.LOSSES_PATH + "losses_breastcancer.csv")
            running_losses_df = pd.read_csv(self.LOSSES_PATH + "running_losses_breastcancer.csv")

        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)


        fig = px.scatter()

        fig.update_xaxes(title_text="( Epoch ) - indicates the number of passes of the entire training dataset the machine learning algorithm has completed.")
        fig.update_yaxes(title_text="Weighted  x-entropy  (change within)")

        fig.update_layout(title_x=0.35, title='   Loss change over epoch ',title_font_size= 18, title_font_color='rgb(0,0,0)')
 
        fig.add_trace(
            go.Line(y=losses_df["train"],name='train', showlegend=True)
        )
            
        fig.add_trace(
            go.Line(y=losses_df["dev"],name='validation',  showlegend=True)
        )
        
        fig.add_trace(
            go.Line(y=losses_df["test"],name='test',  showlegend=True)
        )


        self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
        self.mpl_CanvasToPlot2.resize(1390,750)
#===============================================================================
    def lossConvergence_Function(self):
        print("loss convergence")
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.labelWithPhoto.setVisible(False)

        start_lr = 1e-6
        end_lr = 0.006
        model = self.SettingCNNFilter_Function()
         
        if run_training:
            NUM_EPOCHS = 30
            optimizer = optim.SGD(model.fc.parameters(), lr=0.01)
            scheduler = self.get_scheduler(optimizer, start_lr, end_lr, 2*NUM_EPOCHS)
            results = self.train_loop(model, self.criterion, optimizer, scheduler=scheduler, num_epochs = NUM_EPOCHS)
            model, loss_dict, running_loss_dict = results["model"], results["loss_dict"], results["running_loss_dict"]
            
            if self.device == "cpu":
                OUTPUT_PATH += ".pth"
            else:
                OUTPUT_PATH += "_cuda.pth"
                
            torch.save(model.state_dict(), OUTPUT_PATH)
            
            losses_df = pd.DataFrame(loss_dict["train"],columns=["train"])
            losses_df.loc[:, "dev"] = loss_dict["dev"]
            losses_df.loc[:, "test"] = loss_dict["test"]
            losses_df.to_csv("losses_breastcancer.csv", index=False)
            
            running_losses_df = pd.DataFrame(running_loss_dict["train"], columns=["train"])
            running_losses_df.loc[0:len(running_loss_dict["dev"])-1, "dev"] = running_loss_dict["dev"]
            running_losses_df.loc[0:len(running_loss_dict["test"])-1, "test"] = running_loss_dict["test"]
            running_losses_df.to_csv("running_losses_breastcancer.csv", index=False)
        else:
            if self.device == "cpu":
                load_path = self.MODEL_PATH + ".pth"
            else:
                load_path = self.MODEL_PATH + "_cuda.pth"
            model.load_state_dict(torch.load(load_path, map_location='cpu'))
            model.eval()
            
            losses_df = pd.read_csv(self.LOSSES_PATH + "losses_breastcancer.csv")
            running_losses_df = pd.read_csv(self.LOSSES_PATH + "running_losses_breastcancer.csv")
       
        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot8.setVisible(True)
    

        self.mpl_CanvasToPlot8.ax[0].plot(running_losses_df["train"], label="train")
        self.mpl_CanvasToPlot8.ax[0].set_xlabel("Steps")
        self.mpl_CanvasToPlot8.ax[0].set_ylabel("Weighted x-entropy")
        self.mpl_CanvasToPlot8.ax[0].set_title("Loss change over steps")
        self.mpl_CanvasToPlot8.ax[0].legend();
        self.mpl_CanvasToPlot8.ax[0].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)

        self.mpl_CanvasToPlot8.ax[1].plot(running_losses_df["dev"], label="dev", color="orange")
        self.mpl_CanvasToPlot8.ax[1].set_xlabel("Steps")
        self.mpl_CanvasToPlot8.ax[1].set_ylabel("Weighted x-entropy")
        self.mpl_CanvasToPlot8.ax[1].set_title("Loss change over steps")
        self.mpl_CanvasToPlot8.ax[1].legend();
        self.mpl_CanvasToPlot8.ax[1].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)

        self.mpl_CanvasToPlot8.ax[2].plot(running_losses_df["test"],label="test", color="mediumseagreen")
        self.mpl_CanvasToPlot8.ax[2].set_xlabel("Steps")
        self.mpl_CanvasToPlot8.ax[2].set_ylabel("Weighted x-entropy")
        self.mpl_CanvasToPlot8.ax[2].set_title("Loss change over steps")
        self.mpl_CanvasToPlot8.ax[2].legend();
        self.mpl_CanvasToPlot8.ax[2].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
        # self.mpl_CanvasToPlot4.ax[1].grid(False)
   
            
        self.mpl_CanvasToPlot8.canvas.draw_idle()
        self.mpl_CanvasToPlot8.figure.tight_layout()
        

#===============================================================================
# The probability landscape of invasive ductal carcinoma Â¶
#===============================================================================
    def sigmoid(self,x):
        return 1./(1+np.exp(-x))

#to evaluate the model, parameter is the model used, the predictions dataframe and key
    def evaluate_model(self,model, predictions_df, key):
        was_training = model.training
        model.eval()

        with torch.no_grad():
            for i, data in enumerate(self.dataloaders[key]):
                inputs = data["image"].to(self.device)
                labels = data["label"].to(self.device)
                
                outputs = model(inputs)
                _, preds = torch.max(outputs, 1)
                
                proba = outputs.cpu().numpy().astype(np.float)
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "probability"] = self.sigmoid(proba[:, 1])
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "true"] = data["label"].numpy().astype(np.int)
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "predicted"] = preds.cpu().numpy().astype(np.int)
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "x_coord"] = data["x_coord"].numpy()
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "y_coord"] = data["y_coord"].numpy()
                predictions_df.loc[i*self.BATCH_SIZE:(i+1)*self.BATCH_SIZE-1, "patient_id"] = data["patient_id"]
                
        predictions_df = predictions_df.dropna()
        return predictions_df
#----------------------------------------------------------------------------
    def IDClandscape_Function(self):

        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)

        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot9.setVisible(True)

        if run_training:
            dev_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["dev"]), columns = ["true", "predicted", "probability"])
            test_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["test"]), columns = ["true", "predicted", "probability"])

            dev_predictions = self.evaluate_model(self.model, dev_predictions, "dev")
            test_predictions = self.evaluate_model(self.model, test_predictions, "test")
            
            dev_predictions.to_csv("dev_predictions.csv", index=False)
            test_predictions.to_csv("test_predictions.csv", index=False)
    
        else:
            
            dev_predictions = pd.read_csv(self.LOSSES_PATH + "dev_predictions.csv")
            test_predictions = pd.read_csv(self.LOSSES_PATH + "test_predictions.csv")
            
            dev_predictions.patient_id = dev_predictions.patient_id.astype(np.str)
        
        for n in range(3):

            idx = dev_predictions.patient_id.unique()[n]
            grid, mask, broken_patches, mask_proba = self.visualise_breast_tissue_Images(idx, pred_df=dev_predictions)
   

            self.mpl_CanvasToPlot9.ax[n, 0].imshow(grid, alpha=0.9)
            self.mpl_CanvasToPlot9.ax[n, 1].imshow(mask, alpha=0.8)
            self.mpl_CanvasToPlot9.ax[n, 1].imshow(grid, alpha=0.7)
            self.mpl_CanvasToPlot9.ax[n, 2].imshow(mask_proba[:,:,0], cmap="YlOrRd")

            for m in range(3):
                # self.mpl_CanvasToPlot9.ax[n, m].set_xlabel("y-coord")
                # self.mpl_CanvasToPlot9.ax[n, m].set_ylabel("x-coord")
                self.mpl_CanvasToPlot9.ax[n, m].grid(False)
                # self.mpl_CanvasToPlot9.tight_layout()

            example = "8956"
                
            self.mpl_CanvasToPlot9.ax[n, 0].set_title("Breast tissue slice of patient: " + example)
            self.mpl_CanvasToPlot9.ax[n, 1].set_title("Cancer tissue colored red \n of patient: " + example);
            self.mpl_CanvasToPlot9.ax[n, 2].set_title("Cancer probability");
            self.mpl_CanvasToPlot9.ax[n, 0].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
            self.mpl_CanvasToPlot9.ax[n, 1].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
            self.mpl_CanvasToPlot9.ax[n, 2].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)

        
            self.mpl_CanvasToPlot9.canvas.draw_idle()

#================================================================================

    def validationPredictions(self):
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)

        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)

        if run_training:
            dev_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["dev"]), columns = ["TRUE", "predicted", "probability"])
            test_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["test"]), columns = ["TRUE", "predicted", "probability"])

            dev_predictions = self.evaluate_model(self.model, dev_predictions, "dev")
            test_predictions = self.evaluate_model(self.model, test_predictions, "test")
            
            dev_predictions.to_csv("dev_predictions.csv", index=False)
            test_predictions.to_csv("test_predictions.csv", index=False)
    
        else:
            
            dev_predictions = pd.read_csv(self.LOSSES_PATH + "dev_predictions.csv")
            test_predictions = pd.read_csv(self.LOSSES_PATH + "test_predictions.csv")
            
            dev_predictions.patient_id = dev_predictions.patient_id.astype(np.str)
       
        self.view_graph.setVisible(True)
        self.view_table.setVisible(True)

        # if self.view_table.isChecked():

        #     self.tableView.setVisible(True)        
        #     self.df2= dev_predictions
        #     model = PandasModel(self.df2)
        #     self.tableView.setModel(model)
        #     self.tableView.horizontalHeader().setStretchLastSection(True)
        #     self.tableView.resizeColumnsToContents()
        #     self.tableView.setVisible(True)
        #     self.rowsCount_01.setVisible(True)
        #     self.rowsCount_01.setText(str(model.rowCount())+ " rows found " + "  -->")
        #     self.middleLabel.setVisible(True)
        #     self.middleLabel.setText("Validation/Dev dataset predictions")
        #     self.middleLabel.setGeometry(405,37,1101,33)

        # if self.view_graph.isChecked():
  
        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)

        fig= px.sunburst(dev_predictions, 
                            path=['patient_id', 'TRUE'], 
                            values='probability',
                            color='predicted', 
                            color_continuous_scale='RdBu')
        
        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)
        self.tableView.setVisible(False)   

        self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
        self.mpl_CanvasToPlot2.resize(1390,750)
        self.middleLabel.setVisible(True)
        self.middleLabel.setText("Validation/Dev dataset predictions")
        self.middleLabel.setGeometry(405,37,1101,33)

                    # fig= px.treemap(dev_predictions,             
                                # x="x_coord", 
                                # y="y_coord", 
                                # color="patient_id",
                                # size='probability', 
                                # hover_data=['predicted'])

    
    

#===============================================================================
#validation strategy  selecting 30 % of the 
# patients as test data and the remaining 70 % 
# for training and developing. 
    def setTargetDatadistribution_Function(self):

        
        self.targetdistributions_Function(traindata=70, validationdata=15, testdata=15)

    #def targetdistributions_Function(self,traindata=70, validationdata=15, testdata=15):
    def targetdistributions_Function(self):
            self.hideWidgets()
            self.BigScreenWidget.setVisible(True)
            self.mpl_CanvasToPlot5.setVisible(True)


            patients = self.df.patient_id.unique()
            data=self.df

            # traindata , sub_test_ids = train_test_split(patients,(test_size=30)/100),random_state=0)
            # test_ids = train_test_split(sub_test_ids, (test_size=30)/100),random_state=0)
            #  dev_ids = train_test_split(sub_test_ids,(test_size=30)/100),random_state=0)


            train_ids, sub_test_ids = train_test_split(patients,test_size=0.3,random_state=0)
            test_ids, dev_ids = train_test_split(sub_test_ids, test_size=0.5, random_state=0)
            print("70 percent data for train & 15 percent for dev and 15 for test "+ str(len(train_ids)/patients.shape[0]*100), str(len(dev_ids)/patients.shape[0]*100), str(len(test_ids)/patients.shape[0]*100))
            print(str(len(train_ids)/patients.shape[0]*100), str(len(dev_ids)/patients.shape[0]*100), str(len(test_ids)/patients.shape[0]*100))
            print("patients: distribution"+ str(len(train_ids)), str(len(dev_ids)), str(len(test_ids)) +"  = 279")


            train_df = data.loc[data.patient_id.isin(train_ids),:].copy()
            test_df = data.loc[data.patient_id.isin(test_ids),:].copy()
            dev_df = data.loc[data.patient_id.isin(dev_ids),:].copy()

            self.train_df = self.extract_coords(train_df)
            self.test_df = self.extract_coords(test_df)
            self.dev_df = self.extract_coords(dev_df)

            self.BigScreenWidget.setVisible(True)
            self.mpl_CanvasToPlot2.setVisible(True)
    
            # #=====================================================
            # #making subplots
            fig = make_subplots(rows=1, cols=3,
                    specs=[[{"secondary_y": True}, {"secondary_y": True},
                    {"secondary_y": True}]
                            ])
         
            # #=====================================================
            # #1st column axes
            fig.add_trace(
                go.Histogram(x=train_df.target, name="Train data", showlegend=False),
                row=1, col=1, secondary_y=False,
            )
                
            # #=====================================================
            # #2nd column axes

            fig.add_trace(
            go.Histogram(x=dev_df.target, name="Dev / Validation data", showlegend=False),
                row=1, col=2, secondary_y=False,
            )
            
            
            # #=====================================================
            # #3rd column axes
  
            fig.add_trace(          
            go.Histogram(x=test_df.target, name="Test data",showlegend=False ),
                row=1, col=3, secondary_y=False,
            )
        
       # to color histogram axes1
            fig.data[0].marker.color = ('rgb(243,131,104)','rgb(185,60,13)')
            fig.data[1].marker.color = ('rgb(172,209,233)','rgb(55,157,222)')
            fig.data[2].marker.color = ('rgb(139,205,194)','rgb(104,189,175)')


            fig.update_xaxes(row=1, col=1,title_text="Train data")
            fig.update_xaxes(row=1, col=2,title_text= "Dev / Validation data")
            fig.update_xaxes(row=1, col=3,title_text="Test data")

            fig.update_yaxes(row=1, col=1,title_text="Count")
            fig.update_yaxes(row=1, col=2,title_text="Count")
            fig.update_yaxes(row=1, col=3,title_text="Count")

            fig.update_layout(title='___________________________________ Target distribution difference of the datasets  ____________________________________ ', bargap=0.03,title_font_size= 18, title_font_color='rgb(0,0,0)')

            self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
            self.mpl_CanvasToPlot2.resize(1390,750)
            self.middleLabel.setVisible(True)
            # text= str("Distributing patients data: "+ str(len(train_ids)), str(len(dev_ids)), str(len(test_ids))+  "= 279 patients")
            # str(len(train_ids)/patients.shape[0]*100), str(len(dev_ids)/patients.shape[0]*100), str(len(test_ids)/patients.shape[0]*100)
            self.middleLabel.setText("  Notice: Test data has more cancer patches compared to dev or validation data sets. \n  Non-cancerous patches = 0 (Left), Cancerous patches = 1 (Right) \n  Distributing 70 data for train, 15 for dev/validation and 15 for test ")
            self.middleLabel.setGeometry(432,852,1351,79)

#============================================================================================

    def get_confusion_matrix(self,y_true, y_pred):
        from sklearn.metrics import confusion_matrix

        transdict = {1: "cancer", 0: "no cancer"}
        y_t = np.array([transdict[x] for x in y_true])
        y_p = np.array([transdict[x] for x in y_pred])
        
        labels = ["no cancer", "cancer"]
        index_labels = ["actual no cancer", "actual cancer"]
        col_labels = ["predicted no cancer", "predicted cancer"]
        confusion = confusion_matrix(y_t, y_p, labels=labels)
        confusion_df = pd.DataFrame(confusion, index=index_labels, columns=col_labels)
        for n in range(2):
            confusion_df.iloc[n] = confusion_df.iloc[n] / confusion_df.sum(axis=1).iloc[n]
        return confusion_df
 
    
    def AUC_score_ConfusionMatrix_Function(self):
        print("AUC_score & Confusion Matrix")
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)

        if run_training:
            dev_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["dev"]), columns = ["true", "predicted", "probability"])
            test_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["test"]), columns = ["true", "predicted", "probability"])

            dev_predictions = self.evaluate_model(self.model, dev_predictions, "dev")
            test_predictions = self.evaluate_model(self.model, test_predictions, "test")
            
            dev_predictions.to_csv("dev_predictions.csv", index=False)
            test_predictions.to_csv("test_predictions.csv", index=False)
    
        else:
            
            dev_predictions = pd.read_csv(self.LOSSES_PATH + "dev_predictions.csv")
            test_predictions = pd.read_csv(self.LOSSES_PATH + "test_predictions.csv")
            
            dev_predictions.patient_id = dev_predictions.patient_id.astype(np.str)



        conf_matrix_test = self.get_confusion_matrix(test_predictions.TRUE, test_predictions.predicted)


        # fpr, tpr, thresholds = roc_curve(test_predictions.true, test_predictions.proba)
        # fig, ax = plt.subplots(1,1)
        # ax.plot(fpr,tpr); ax.set_xlabel('False Positive Rate') ; ax.set_ylabel('True Positive Rate'); plt.title('ROC curve - Dev (validation)')
        # # print(thresholds)
        
        from sklearn.metrics import classification_report,balanced_accuracy_score, roc_curve,roc_auc_score
        auc_score_test = roc_auc_score(test_predictions.TRUE, test_predictions.probability)

        self.middleLabel.setGeometry(QtCore.QRect(432, 165, 371, 171))
        self.labelWithPhoto.setVisible(True)
        self.middleLabel.setVisible(True)                                                                                                                                   
    
     
        self.middleLabel.setText("--------- Confusion Matrix - Test set  ----------\n" + str(conf_matrix_test) )
        # '\nBalanced Accuracy score: ' + str(balanced_accuracy_score(test_predictions.TRUE, test_predictions.predicted)+ '\nAUC score:'+ auc_score_test))
        #  + classification_report(test_predictions.TRUE)))
        # test_predictions.predicted, target_names=['actual no cancer', 'actual cancer']))+'\nBalanced Accuracy score: ' + str(balanced_accuracy_score(test_predictions.TRUE, test_predictions.predicted)+ '\nAUC score:'+ auc_score_test))


#============================================================================================
    def viewAllpatientsProbabilityResult_Function(self):
        print("Viewing all patient's probability result")
        self.hideWidgets()
        self.createDatabase()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)

        self.tableView.setVisible(True)

        if run_training:
            dev_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["dev"]), columns = ["TRUE", "predicted", "probability"])
            test_predictions = pd.DataFrame(index = np.arange(0, self.dataset_sizes["test"]), columns = ["TRUE", "predicted", "probability"])

            dev_predictions = self.evaluate_model(self.model, dev_predictions, "dev")
            test_predictions = self.evaluate_model(self.model, test_predictions, "test")
            
            dev_predictions.to_csv("dev_predictions.csv", index=False)
            test_predictions.to_csv("test_predictions.csv", index=False)
    
        else:
            
            dev_predictions = pd.read_csv(self.LOSSES_PATH + "Cleaned_dev_predictions.csv")
            test_predictions = pd.read_csv(self.LOSSES_PATH + "Cleaned_test_predictions.csv")
            
            dev_predictions.patient_id = dev_predictions.patient_id.astype(np.str)

        test_predictions.to_csv("test_predictions.csv", index=False)
        test_predictions
        
        self.df2= test_predictions
        model = PandasModel(self.df2)
        self.tableView.setModel(model)
        self.tableView.horizontalHeader().setStretchLastSection(True)
        self.tableView.resizeColumnsToContents()
        self.tableView.setVisible(True)
        self.rowsCount_01.setVisible(True)
        self.rowsCount_01.setText(str(model.rowCount())+ " rows found " + "  -->")
        self.middleLabel.setVisible(True)
        self.middleLabel.setText("This is all the test data patient's predictions")
        self.middleLabel.setGeometry(405,37,1101,33)



        
        # if self.view_table.isChecked():

        #     self.tableView.setVisible(True)        
        #     self.df2= dev_predictions
        #     model = PandasModel(self.df2)
        #     self.tableView.setModel(model)
        #     self.tableView.horizontalHeader().setStretchLastSection(True)
        #     self.tableView.resizeColumnsToContents()
        #     self.tableView.setVisible(True)
        #     self.rowsCount_01.setVisible(True)
        #     self.rowsCount_01.setText(str(model.rowCount())+ " rows found " + "  -->")
        #     self.middleLabel.setVisible(True)
        #     self.middleLabel.setText("Validation/Dev dataset predictions")
        #     self.middleLabel.setGeometry(405,37,1101,33)

        # if self.view_graph.isChecked():
  
        # self.BigScreenWidget.setVisible(True)
        # self.mpl_CanvasToPlot2.setVisible(True)

        # fig= px.sunburst(dev_predictions, 
        #                     path=['patient_id', 'TRUE'], 
        #                     values='probability',
        #                     color='predicted', 
        #                     color_continuous_scale='RdBu')
        
        # self.BigScreenWidget.setVisible(True)
        # self.mpl_CanvasToPlot2.setVisible(True)
        # self.tableView.setVisible(False)   

        # self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
        # self.mpl_CanvasToPlot2.resize(1390,750)
        # self.middleLabel.setVisible(True)
        # self.middleLabel.setText("Validation/Dev dataset predictions")
        # self.middleLabel.setGeometry(405,37,1101,33)

                    # fig= px.treemap(dev_predictions,             
                                # x="x_coord", 
                                # y="y_coord", 
                                # color="patient_id",
                                # size='probability', 
                                # hover_data=['predicted'])

    

#=========================================================================
#the function for the checkbox (negative & positive)
    def CheckBox_Function(self):
        text= self.searchPatientID.text() # value end-user entered in Qlineedit object to search patientid
        dt0 = self.db.execute("SELECT TRUE,predicted,probability,x_coord,y_coord,patient_id  FROM breastCancer_Predictions WHERE TRUE = 0 AND  patient_id LIKE '%"+text+"%'  ").fetchall() 
        df0= pd.DataFrame(dt0, columns = [ 'TRUE','predicted','probability','x_coord','y_coord','patient_id'])        
       
        dt1 = self.db.execute("SELECT TRUE,predicted,probability,x_coord,y_coord,patient_id  FROM breastCancer_Predictions WHERE TRUE = 1 AND  patient_id LIKE '%"+text+"%'  ").fetchall() 
        df1= pd.DataFrame(dt1, columns = [ 'TRUE','predicted','probability','x_coord','y_coord','patient_id'])        
              
        
        if self.negative_Checkbox.isChecked():
            print("viewing negative predictions")
            self.positive_Checkbox.setChecked(False)

            if self.searchPatientID.text():
                self.reusabledisplay_Function(text, df0)

            if not self.searchPatientID.text():
                self.reusabledisplay_Function(text, df0)
                self.middleLabel.setText("This is all the test data patient's predictions (for negative)")  

        if self.positive_Checkbox.isChecked():
            print("viewing positive predictions")
            self.negative_Checkbox.setChecked(False)

            if self.searchPatientID.text():
                self.reusabledisplay_Function(text, df1)

            if not self.searchPatientID.text():
                self.reusabledisplay_Function(text, df1)
                self.middleLabel.setText("This is all the test data patient's predictions (for positive)")  

        if not self.positive_Checkbox.isChecked() and not self.negative_Checkbox.isChecked():
            print("resetting checkbox ")
            self.middleLabel.setText("This is all the test data patient's predictions")
            dt = self.db.execute("SELECT TRUE,predicted,probability,x_coord,y_coord,patient_id  FROM breastCancer_Predictions WHERE patient_id LIKE '%"+text+"%'  ").fetchall() 
            df= pd.DataFrame(dt, columns = [ 'TRUE','predicted','probability','x_coord','y_coord','patient_id'])        
            self.reusabledisplay_Function(text, df)

#============================================================================
    def searchPatient_Function(self):
        text= self.searchPatientID.text() # value end-user entered in Qlineedit object to search patientid
        print(text) 
        dt = self.db.execute("SELECT TRUE,predicted,probability,x_coord,y_coord,patient_id  FROM breastCancer_Predictions WHERE patient_id LIKE '%"+text+"%' ").fetchall() 
        df= pd.DataFrame(dt, columns = [ 'TRUE','predicted','probability','x_coord','y_coord','patient_id'])
        
        self.reusabledisplay_Function(text,df)

   #creating reusable display table view prediction result function
    def reusabledisplay_Function(self,text,df):
        self.hideWidgets()
        self.tableView.setVisible(True)
        self.rowsCount_01.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.tableView.reset()
        self.progressBar.setVisible(False)

        self.model = PandasModel(df)   
        self.tableView.setModel(self.model)
        self.tableView.resizeColumnsToContents()
        self.rowsCount_01.setText(str(self.model.rowCount())+ " rows found " + "  -->")
  
        self.middleLabel.setVisible(True)
        self.middleLabel.setGeometry(405,37,1101,33)
        if self.searchPatientID.text():
            if self.positive_Checkbox.isChecked():
              self.middleLabel.setText("This is patient # "+ text  +" (positive) predictions")
            if self.negative_Checkbox.isChecked():
              self.middleLabel.setText("This is patient # "+ text  +" (negative) predictions")
        if not self.searchPatientID.text():
            if self.positive_Checkbox.isChecked():
                self.middleLabel.setText(" Test data predictions")
            if self.negative_Checkbox.isChecked():
               self.middleLabel.setText(" Test data predictions")
    
        return df

#============================================================================================
    def exportPredictionResult_Function(self):
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)
        self.tableView.setVisible(True)
        
        print("Exporting prediction result in to a .csv file")

        df = self.reusabledisplay_Function()

        fileName, _ =  QtWidgets.QFileDialog.getSaveFileName(self,"Save",os.getcwd(),"CSV Files (*.csv)")

        df.to_csv(fileName, index=False)
            
        # if fileName:
        #     with open(fileName, "w") as file:
        #       file.write(df)

        
        # dev_predictions.to_csv("dev_predictions.csv", index=False)

#============================================================================================
    #to flip the images 
    def my_transform(self,key="train", plot=False):
            train_sequence = [transforms.Resize((50,50)),
                            transforms.RandomHorizontalFlip(),
                            transforms.RandomVerticalFlip()]
            val_sequence = [transforms.Resize((50,50))]
            if plot==False:
                train_sequence.extend([
                    transforms.ToTensor(),
                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])
                val_sequence.extend([
                    transforms.ToTensor(),
                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])
                
            data_transforms = {'train': transforms.Compose(train_sequence),'val': transforms.Compose(val_sequence)}
            return data_transforms[key]  

#=====================================================================================
   #to create datasets for the next layers, filter the images and take the first layer output images and use it as an input for the next CNN layer
    def createDatasets (self):
            print("creating datasets")
            self.hideWidgets()
            self.BigScreenWidget.setVisible(True)
            self.mpl_CanvasToPlot6.setVisible(True)

            train_transform = self.my_transform(key="train", plot=True)
            val_transform = self.my_transform(key="val", plot=True)
        
            for m in range(6):
                filepath = self.train_df.path.values[m]
                image = PIL.Image.open(filepath)
                self.mpl_CanvasToPlot6.ax[0,m].imshow(image)
                transformed_img = train_transform(image)
                self.mpl_CanvasToPlot6.ax[1,m].imshow(transformed_img)
                self.mpl_CanvasToPlot6.ax[2,m].imshow(val_transform(image))
                self.mpl_CanvasToPlot6.ax[0,m].grid(False)
                self.mpl_CanvasToPlot6.ax[1,m].grid(False)
                self.mpl_CanvasToPlot6.ax[2,m].grid(False)
                self.mpl_CanvasToPlot6.ax[0,m].set_title(str(self.train_df.patient_id.values[m]) + "\n target: " + str(self.train_df.target.values[m]))
                self.mpl_CanvasToPlot6.ax[1,m].set_title("Preprocessing for train")
                self.mpl_CanvasToPlot6.ax[2,m].set_title("Preprocessing for val")
                self.mpl_CanvasToPlot6.ax[0,m].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
                self.mpl_CanvasToPlot6.ax[1,m].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
                self.mpl_CanvasToPlot6.ax[2,m].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)

            self.mpl_CanvasToPlot6.figure.suptitle("            Image patch of a patient is converted in to RGB and the augmentation is performed, \n This is the output of the first layer and will be the input for the next CNN Layer", x=0.3 )    
            self.mpl_CanvasToPlot6.canvas.draw_idle()  
#====================================================================================================
#=================Functions==========================================================================   
# 
    def progressbarAnimation(self,pB): 
        #setting for loop to set value of progress bar
        for i in range(25):
            # slowing down the loop
            time.sleep(0.01)
            # setting value to progress bar
            pB.setValue(i) 


#=========================================================
    def progressbarAnimation2(self,pB): 
        #setting for loop to set value of progress bar
        for i in range(25):
            # slowing down the loop
            time.sleep(0.01)
            # setting value to progress bar
            pB.setValue(i) 

#====================================================================

    def createDatabase(self):  #this function is only use to create the database"

        # engine = sqlalchemy.create_engine('sqlite:///breastcancerprediction.db') #to create database engine if not yet created
        self.df = pd.read_csv('./breastcancermodel/Cleaned_test_predictions.csv',encoding='latin-1',index_col=[0])
        #creating table in database and its columns
        connection = sqlite3.connect('breastcancerprediction.db')                                                                                                                                                                                                                                                                                                                                                        
        create_sqltable = """CREATE TABLE IF NOT EXISTS Cleaned_test_predictions ("TRUE" VARCHAR NOT NULL,"predicted" VARCHAR NOT NULL,"probability" VARCHAR NOT NULL, "x_coord" VARCHAR NOT NULL,  "y_coord" VARCHAR NOT NULL, "patient_id" VARCHAR NOT NULL )"""
        cursor = connection.cursor()
        cursor.execute(create_sqltable)
        self.df.to_sql('Cleaned_test_predictions', connection, if_exists='replace') 
        print("database created")    

        # dt = self.db.execute( """SELECT TRUE, predicted,probability,x_coord,y_coord, patient_id  FROM dev_predictions """)
        # df= pd.DataFrame(dt, columns = [ 'TRUE', 'predicted','probability','x_coord', 'y_coord', 'patient_id' ])  
        # df.to_csv("C:/Users/a_ade/Desktop/Files/Capstone/Breast_Cancer/breastcancermodel/Cleaned_dev_predictions.csv", sep=',', encoding='latin-1')

#====================================================
  #function for Qfiledialog that let user select folders but also view what's in it , 
  # this is connected to the Object OOP imported above from another python file "DirProxyModel" 
    def selectDirectory(self):
        print("browse folder button was pressed")
        file_filter = 'All files(*.*);; Images files(*.png) ;;';
        dialog = QtWidgets.QFileDialog(
        parent=self,
        caption= "Select folder",
        directory= os.getcwd(),
        filter= file_filter,           # shows dialog box and return the path
                )       
        dialog.setDirectory("C:/Users/a_ade/Desktop/Files/Capstone/Breast_Cancer/breast-histopathology-images/IDC_regular_ps50_idx5/")
        dialog.setFileMode(dialog.Directory)
        dialog.setOptions(dialog.DontUseNativeDialog) 
        
        #**********************************************************
        #to show folders containing files but not clickable
        # find the underlying model and set our own proxy model for it
        for view in self.findChildren(QtWidgets.QAbstractItemView):
        # try to hide the file filter combo
            fileTypeCombo = dialog.findChild(QtWidgets.QComboBox, 'fileTypeCombo')
            if fileTypeCombo:
                fileTypeCombo.setVisible(False)
                dialog.setLabelText(dialog.FileType, '')            
            view.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection) 

            # we used OOP object here (DirProxyModel)
            if isinstance(view.model(), QtWidgets.QFileSystemModel):             
                    proxyModel = DirProxyModel(view.model())       
                    dialog.setProxyModel(proxyModel)

        if dialog.exec_():
            #this is to print the folder's path in Qlistwidget    
            self.folders= dialog.selectedFiles()
            for i in range(len(self.folders)):
                if self.folders is None: 
                        pass
               
                else: 
                    
                     #this is to print the folders path in Qlistwidget and also to save table in database 

                #     print(self.folders[i]) 
                 
                    self.hideWidgets()

                    self.progressBar.setVisible(True)
                    self.progressbarAnimation(self.progressBar)
                    self.progressBar.setVisible(False)
                    self.labelWithPhoto.setVisible(False)

#***************************This code is to print the directory path and make a pandas dataframe of it then output into a .csv file
    #                 f=(str(self.folders))
    #                 f2 =  re.sub(r"[\([{})'\]]", "", f)
    #                 folder = listdir(f2)
    #                 base_path= "C:/Users/a_ade/Desktop/Files/Capstone/Breast_Cancer/breast-histopathology-images/IDC_regular_ps50_idx5/"
              

    #                 total_images= 0

    #                 for n in range(len(folder)):
    #                     patient_id = folder[n]
                        
    #                     for c in [0, 1]:
    #                             patient_path = base_path + patient_id 
    #                             class_path = patient_path + "/" + str(c) + "/"
    #                             subfiles = listdir(class_path)
    #                             total_images += len(subfiles)

    #    ## ============================making dataframe of the images directory path
    #                 data = pd.DataFrame(index=np.arange(0, total_images), columns=["patient_id", "path", "target"])

    #                 k = 0
    #                 for n in range(len(folder)):
    #                     patient_id = folder[n]
                        
    #                     patient_path = base_path + patient_id 
    #                     for c in [0,1]:
    #                         class_path = patient_path + "/" + str(c) + "/"
    #                         subfiles = listdir(class_path)
    #                         for m in range(len(subfiles)):
    #                             image_path = subfiles[m]
    #                             # class_path +image_path
    #                             data.iloc[k]["path"] =   class_path + image_path
    #                             data.iloc[k]["target"] = c
    #                             data.iloc[k]["patient_id"] = patient_id
    #                             k += 1  

                      
    #                 print("dataframe for path created")
    #                 self.file = []
    #                 self.file.append(self.folders)
    #                 self.f = str(self.file[0])

    #                 data.to_csv('testoutput.csv', mode='a',index=False, header=not os.path.exists('testoutput.csv'))
#**************************====================================================================    

                    self.path =  'C:/Users/a_ade/Desktop/Files/Capstone/Breast_Cancer/testoutput.csv'
                    self.df = pd.read_csv(self.path)
                                  
                    self.df2= self.df
                    model = PandasModel(self.df2)
                    self.tableView.setModel(model)
                    self.tableView.resizeColumnsToContents()
                    self.tableView.setVisible(True)
                    self.rowsCount_01.setVisible(True)
                    self.rowsCount_01.setText(str(model.rowCount())+ " rows found " + "  -->")
                    
#================================================================================
    def getdataCounts(self):
        print("Printing data counts")
        self.hideWidgets()

        self.middleLabel.setGeometry(QtCore.QRect(432, 165, 371, 171))
        total_images = 0
        for n in range(len(self.folders_list)):
            patient_id =  self.folders_list[n]
            for c in [0, 1]:
                patient_path = self.base_path + patient_id 
                class_path = patient_path + "/" + str(c) + "/"
                subfiles = listdir(class_path)
                total_images += len(subfiles)

        self.labelWithPhoto.setVisible(True)
        self.middleLabel.setVisible(True)
    
     
        self.middleLabel.setText("--------- DATA COUNTS ----------" +"\n Total number of images: " + str(total_images) +"\n Total number of patients: "+ str(len(self.folders_list)) + "\n Average data per patient: 990 microscopic images")
        print("Total number of images: " + str(total_images))
               
 #===================================================================             
    def showUploadedFilesFunction(self):
            print("Show uploaded files path")
            self.hideWidgets()

            self.labelWithPhoto.setVisible(True)   
            # self.BigScreenWidget.setVisible(True)     
      
            self.progressBar.setVisible(True)
            self.progressbarAnimation(self.progressBar)
            self.progressBar.setVisible(False)       

            pathfiles =  'C:/Users/a_ade/Desktop/Files/Capstone/Breast_Cancer/testoutput.csv'
            self.df3 = pd.read_csv(pathfiles)
                
            self.df4= self.df3
            model = PandasModel(self.df4)
            self.tableView.setModel(model)
            self.tableView.resizeColumnsToContents()
            self.progressBar2.setVisible(False)

            self.tableView.setVisible(True)
            self.labelWithPhoto.setVisible(False)
            self.rowsCount_01.setVisible(True)
            self.rowsCount_01.setText(str(model.rowCount())+ " rows found " + "  -->")
#==============================================================================
#==============================================================================
   #this function is used by other functions
   #to get the x and y coordinates of the tissue images dimensions
    def extract_coords(self,df):
        coord = df.path.str.rsplit("_", n=4, expand=True)
        coord = coord.drop([0, 1, 4], axis=1)
        coord = coord.rename({2: "x", 3: "y"}, axis=1)
        coord.loc[:, "x"] = coord.loc[:,"x"].str.replace("x", "", case=False).astype(np.int)
        coord.loc[:, "y"] = coord.loc[:,"y"].str.replace("y", "", case=False).astype(np.int)
        df.loc[:, "x"] = coord.x.values
        df.loc[:, "y"] = coord.y.values
        return df

   #this function is to get the cancer dataframe with its x and y coordinates
    def get_cancer_dataframe(self,patient_id, cancer_id):
        path = self.base_path + patient_id + "/" + cancer_id
        files = listdir(path)
        dataframe = pd.DataFrame(files, columns=["filename"])
        path_names = path + "/" + dataframe.filename.values
        dataframe = dataframe.filename.str.rsplit("_", n=4, expand=True)
        dataframe.loc[:, "target"] = np.int(cancer_id)
        dataframe.loc[:, "path"] = path_names
        dataframe = dataframe.drop([0, 1, 4], axis=1)
        dataframe = dataframe.rename({2: "x", 3: "y"}, axis=1)
        dataframe.loc[:, "x"] = dataframe.loc[:,"x"].str.replace("x", "", case=False).astype(np.int)
        dataframe.loc[:, "y"] = dataframe.loc[:,"y"].str.replace("y", "", case=False).astype(np.int)
        return dataframe

   #we used the function above inside this function to get the patient's dataframe
    def get_patient_dataframe(self,patient_id):
        df_0 = self.get_cancer_dataframe(str(patient_id), "0")
        df_1 = self.get_cancer_dataframe(str(patient_id), "1")
        patient_df = df_0.append(df_1)
        return patient_df

     #to visualize breast tissue slice via binary using the patient dataframe w/ values of x and y coordinates
    def visualizeBreastTissueSliceBinary_Function(self):
        print("Visualizing breast tissue slice")
        self.hideWidgets()

        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot3.setVisible(True)

        patient_id = "10269" #using this patient sample to visualize in binary
        example_df = self.get_patient_dataframe(patient_id)
        
        self.mpl_CanvasToPlot3.ax[0].scatter(example_df.x.values, example_df.y.values, c=example_df.target.values, cmap="autumn",);
        self.mpl_CanvasToPlot3.ax[0].set_title("patient " + str(patient_id))
        self.mpl_CanvasToPlot3.ax[0].set_xlabel("x coord")
        self.mpl_CanvasToPlot3.ax[0].set_ylabel("y coord")
        self.mpl_CanvasToPlot3.ax[0].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
    

        self.mpl_CanvasToPlot3.ax[1].scatter(example_df.x.values, example_df.y.values, c=example_df.target.values, cmap="autumn",);
        self.mpl_CanvasToPlot3.ax[1].set_title("patient " + str(patient_id))
        self.mpl_CanvasToPlot3.ax[1].set_xlabel("x coord")
        self.mpl_CanvasToPlot3.ax[1].set_ylabel("y coord")
        self.mpl_CanvasToPlot3.ax[1].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
        self.mpl_CanvasToPlot3.canvas.draw_idle()  
        self.mpl_CanvasToPlot3.figure.suptitle("                                                Binary target visualization per tissue slice. (Extracting all coordinates of image patches that are stored in the image names\n  and use the coordinates to reconstruct the whole breast tissue of a patient. ", x=0.41)  

#==============================================================================
     #function to highlight cancerous patches
    def visualise_breast_tissue_Images(self,patient_id, pred_df=None):
        print("Visualizing breast tissue images")

        example_df = self.get_patient_dataframe(patient_id)
        max_point = [example_df.y.max()-1, example_df.x.max()-1]
        grid = 255*np.ones(shape = (max_point[0] + 50, max_point[1] + 50, 3)).astype(np.uint8)
        mask = 255*np.ones(shape = (max_point[0] + 50, max_point[1] + 50, 3)).astype(np.uint8)
        if pred_df is not None:
            patient_df = pred_df[pred_df.patient_id == patient_id].copy()
        mask_proba = np.zeros(shape = (max_point[0] + 50, max_point[1] + 50, 1)).astype(np.float)
        
        broken_patches = []
        for n in range(len(example_df)):
            try:
                image = imread(example_df.path.values[n])
                
                target = example_df.target.values[n]
                
                x_coord = np.int(example_df.x.values[n])
                y_coord = np.int(example_df.y.values[n])
                x_start = x_coord - 1
                y_start = y_coord - 1
                x_end = x_start + 50
                y_end = y_start + 50
  
            #to highlight the cancerous patches and change its color intensity
                grid[y_start:y_end, x_start:x_end] = image
                if target == 1:
                    mask[y_start:y_end, x_start:x_end, 0] = 250
                    mask[y_start:y_end, x_start:x_end, 1] = 0
                    mask[y_start:y_end, x_start:x_end, 2] = 0
                if pred_df is not None:
                    
                    probability = patient_df[
                        (patient_df.x_coord==x_coord) & (patient_df.y_coord==y_coord)].probability
                    mask_proba[y_start:y_end, x_start:x_end, 0] = np.float(probability)

            except ValueError:
                broken_patches.append(example_df.path.values[n])
        
        return grid, mask, broken_patches, mask_proba

#function to highlight cancerous patches/ function above is used in this function
    def visualizeBreastTissueImages_Function(self):
            self.hideWidgets()
            self.labelWithPhoto.setVisible(True)
            self.progressBar.setVisible(True)
            self.progressbarAnimation(self.progressBar)
            self.progressBar.setVisible(False)
            self.labelWithPhoto.setVisible(False)

            self.BigScreenWidget.setVisible(True)
            self.mpl_CanvasToPlot4.setVisible(True)

            example = "8956"
            grid, mask, broken_patches,_ = self.visualise_breast_tissue_Images(example)
            
            self.mpl_CanvasToPlot4.ax[0].imshow(grid, alpha=0.9)
            self.mpl_CanvasToPlot4.ax[1].imshow(mask, alpha=0.8)
            self.mpl_CanvasToPlot4.ax[1].imshow(grid, alpha=0.7)
            self.mpl_CanvasToPlot4.ax[0].grid(False)
            self.mpl_CanvasToPlot4.ax[1].grid(False)
            
              
            # self.mpl_CanvasToPlot4.ax[0].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
            # self.mpl_CanvasToPlot4.ax[1].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
            self.mpl_CanvasToPlot4.ax[0].set_title("Breast tissue slice of patient: " + example)
            self.mpl_CanvasToPlot4.ax[1].set_title("Cancer tissue colored red \n of patient: " + example);
            self.mpl_CanvasToPlot4.canvas.draw_idle()  
            self.mpl_CanvasToPlot4.figure.suptitle("Using the data from patient: 8956  ", x=0.46)      

#==============================================================================
#==============================================================================
#To view random cancerous patches vs healthy patches / cancerous mostly indicates a dark purple 
    def breastTissuePatches_Function(self):
        print("Viewing breast tissue patches")
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)

        self.plottingLeftWidget.setVisible(True)
        self.plottingRightWidget.setVisible(True)

        #df is the path of the microscopic images, variable declare at class uIStructure.py file
        self.df.target = self.df.target.astype(np.int)
        #it selects random data that is already classified as 0 or 1 stored in a folder
        pos_selection = np.random.choice(self.df[self.df.target==1].index.values, size=35, replace=False)
        neg_selection = np.random.choice(self.df[self.df.target==0].index.values, size=35, replace=False)

        # self.mpl_CanvasToPlot.figure.clear()
        for row in range(5):
           for col in range(7):
                idx = pos_selection[col + 7*row]
                image = imread(self.df.loc[idx, "path"])

                self.mpl_LeftCanvasToPlot.ax[row,col].imshow(image)
                self.mpl_LeftCanvasToPlot.ax[row,col].grid(False)
                # self.mpl_LeftCanvasToPlot.ax[row,col].axis('off')
                self.mpl_LeftCanvasToPlot.ax[row,col].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
       
        self.mpl_LeftCanvasToPlot.canvas.draw_idle()     
        self.mpl_LeftCanvasToPlot.figure.suptitle("Cancer patches", x=0.3 )    
                
        for row in range(5):
               for col in range(7):
                idx = neg_selection[col + 7*row]
                image = imread(self.df.loc[idx, "path"])

                self.mpl_RightCanvasToPlot.ax[row,col].cla()  
                self.mpl_RightCanvasToPlot.ax[row,col].imshow(image)
                self.mpl_RightCanvasToPlot.ax[row,col].grid(False)
                # self.mpl_RightCanvasToPlot.ax[row,col].axis('off')
                self.mpl_RightCanvasToPlot.ax[row,col].tick_params(labelbottom=False, bottom=False,labelleft=False, left=False)
       
        self.mpl_RightCanvasToPlot.canvas.draw_idle()
        self.mpl_RightCanvasToPlot.figure.suptitle("Healthy patches", x = 0.3)    
       
  #=============================================================================      
   #to hide some widgets, while showing current called widgets
    def hideWidgets(self):
            self.mpl_CanvasToPlot3.setVisible(False)
            self.mpl_CanvasToPlot7.setVisible(False)
            self.mpl_CanvasToPlot4.setVisible(False)
            self.mpl_CanvasToPlot6.setVisible(False)
            self.middleLabel.setVisible(False)
            self.plottingLeftWidget.setVisible(False)
            self.plottingRightWidget.setVisible(False)
            self.tableView.setVisible(False)
            self.mpl_CanvasToPlot.setVisible(False)
            self.BigScreenWidget.setVisible(False)
            self.rowsCount_01.setVisible(False)
            self.view_graph.setVisible(False)
            self.view_table.setVisible(False)
            self.view_graph1.setVisible(False)
            self.view_table1.setVisible(False)

            self.mpl_CanvasToPlot4.setVisible(False)
            self.labelWithPhoto.setVisible(True)
            self.rowsCount_01.setVisible(False)
            self.labelWithPhoto.setVisible(False)
            self.mpl_CanvasToPlot2.setVisible(False)
            self.mpl_CanvasToPlot3.setVisible(False)
            self.mpl_CanvasToPlot5.setVisible(False)
            self.plottingLeftWidget.setVisible(False)
            self.plottingRightWidget.setVisible(False)
            self.mpl_CanvasToPlot8.setVisible(False)
            self.mpl_CanvasToPlot9.setVisible(False)

#==============================================================================
#reviewing patches in all microscopic images, such as how many patches are covered with IDC Cancer
    def reviewPatches_Function(self):
        print("Reviewing patches")
        self.hideWidgets()
        self.labelWithPhoto.setVisible(True)
        self.progressBar.setVisible(True)
        self.progressbarAnimation(self.progressBar)
        self.progressBar.setVisible(False)
        self.labelWithPhoto.setVisible(False)

        self.BigScreenWidget.setVisible(True)
        self.mpl_CanvasToPlot2.setVisible(True)
   
        # #=====================================================
        # #making subplots
        fig = make_subplots(rows=1, cols=3,
                  specs=[[{"secondary_y": True}, {"secondary_y": True},
                  {"secondary_y": True}]
                        ])
        # #=====================================================
        # #1st column axes
        fig.add_trace(
            go.Histogram(x=self.df.groupby("patient_id").size(), name="# of patches", showlegend=False),
            row=1, col=1, secondary_y=False,
        )
            
        # #=====================================================
        # #2nd column axes
        cancer_perc = self.df.groupby("patient_id").target.value_counts()/ self.df.groupby("patient_id").target.size()
        cancer_perc = cancer_perc.unstack()

        fig.add_trace(
           go.Histogram(x=(cancer_perc.loc[:, 1]*100), name="% of patches w/ IDC", showlegend=False),
            row=1, col=2, secondary_y=False,
        )
        
        
        # #=====================================================
        # #3rd column axes
        fig.add_trace(          
        go.Histogram(x=self.df.target, name="no(0) versus yes(1)", showlegend=False ),
            row=1, col=3, secondary_y=False,
        )
     
       #to color histogram axes1
        fig.data[0].marker.color = ('springgreen','yellowgreen','paleturquoise','darkolivegreen','green','darkseagreen','mediumseagreen','mediumspringgreen','mediumturquoise','teal','seagreen','turquoise')


        #to color histogram axes2
        fig.data[1].marker.color = ('mistyrose', 'palevioletred',
            'honeydew', 'darkorchid', 'peachpuff', 'deeppink', 'pink',
            'plum', 'purple', 'rosybrown',
            'royalblue', 'rebeccapurple', 'lightcoral', 'salmon',
            'hotpink', 'magenta', 'mediumorchid', 'mediumpurple',
             'lavenderblush' )

        #to color histogram axes3  "no vs yes"
        fig.data[2].marker.color = ('mediumspringgreen','red')

        fig.update_xaxes(row=1, col=1,title_text="Number of patches")
        fig.update_xaxes(row=1, col=2,title_text= "% of patches w/ IDC")
        fig.update_xaxes(row=1, col=3,title_text="no(0)    versus    yes(1)")

        fig.update_yaxes(row=1, col=1,title_text="Frequency")
        fig.update_yaxes(row=1, col=2,title_text="Frequency")
        fig.update_yaxes(row=1, col=3,title_text="Count")

        fig.update_layout(title='How many patches do we have per patient?                                 How much percentage of an image is covered by IDC?                                    How many patches show IDC ', bargap=0.03,title_font_size= 12, title_font_color='rgb(0,0,0)')

        self.mpl_CanvasToPlot2.setHtml(fig.to_html(include_plotlyjs='cdn'))
        self.mpl_CanvasToPlot2.resize(1390,750)


#==============================================================================
#==============================================================================
    def retranslateUi(self, mainWindow):
        _translate = QtCore.QCoreApplication.translate
        mainWindow.setWindowTitle(_translate("mainWindow", "GVEO "))
        self.labelMainTitle.setText(_translate("mainWindow", "        MACHINE LEARNING  - Breast Cancer Prediction"))
        self.labelTitleCNN.setText(_translate("mainWindow", "Convolutional neural network"))
        self.uploadFilesbutton.setText(_translate("mainWindow", "Upload files"))
        self.uploadfilesLabel.setText(_translate("mainWindow", "Upload path (cell tissue images) "))
        self.EDALabel.setText(_translate("mainWindow", "     EXPLORATORY DATA ANALYSIS      "))
        self.showUploadedFilesButton.setText(_translate("mainWindow", "Show uploaded files"))
        self.dataCounts.setText(_translate("mainWindow", "Data counts"))
        self.reviewPatches.setText(_translate("mainWindow", "Review Patches"))
        self.view_table.setText(_translate("mainWindow", "View Table"))
        self.view_graph.setText(_translate("mainWindow", "View Graph"))
        self.view_table1.setText(_translate("mainWindow", "View Table"))
        self.view_graph1.setText(_translate("mainWindow", "View Graph"))
        self.visualizeBinary.setText(_translate("mainWindow", "Visualize  breast tissue slice (binary target)"))
        self.visualizeBreastTissue.setText(_translate("mainWindow", "Highlight cancerous patches"))
        self.viewBreastTissueLabel.setText(_translate("mainWindow", "          VIEW TISSUES       "))
        self.breastTissuePatches.setText(_translate("mainWindow", " breast tissue patches (cancerous and healthy)"))
        self.machineLearningModelLabel.setText(_translate("mainWindow", "     MACHINE LEARNING (CNN)      "))
        self.ViewDatasets.setText(_translate("mainWindow", "View (training, validation, and  test data sets)"))
        self.createDatasetButton.setText(_translate("mainWindow", "2nd Layer input of CNN"))
        self.applyCNNfilter_Button.setText(_translate("mainWindow", "  Apply CNN Filter"))
        self.LowLRButton.setText(_translate("mainWindow", "  start_lr = 1e-6\nend_lr = 0.006"))
        self.HighLRButton.setText(_translate("mainWindow", "   start_lr = 1e-6\nend_lr = 0.1"))
       
        self.lossConvergenceButton.setText(_translate("mainWindow", "   View Loss convergence"))

        self.idcprobabilityMap_button.setText(_translate("mainWindow", "  (IDC) Cancer probability landscape"))
        self.validationDataSet_Button.setText(_translate("mainWindow", " Validation predictions "))
        self.validationConfusionMatrix_Button.setText(_translate("mainWindow", "AUC Score and confusion matrix "))
        self.viewAllpatients_probabilityButton.setText(_translate("mainWindow", "View all patient's probability result"))
        self.negative_Checkbox.setText(_translate("mainWindow", "negative"))
        self.positive_Checkbox.setText(_translate("mainWindow", "positive"))

        self.SearchLearningRatelabel.setText(_translate("mainWindow", "  (Search optimal cyclical learning rate)"))
        self.datadistributionLabel.setText(_translate("mainWindow", "Set data distribution ( with total sum of 100%)"))
        self.train.setPlaceholderText(_translate("mainWindow", "train"))
        self.validationdata_.setPlaceholderText(_translate("mainWindow", "dev"))
        self.testdata_.setPlaceholderText(_translate("mainWindow", "test"))
        self.searchPatientID.setPlaceholderText(_translate("mainWindow", "   Search Patient ID..."))
        self.predictionResult.setText(_translate("mainWindow", "Export Prediction Result"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("mainWindow", "Table"))
        self.uploadCSV.setText(_translate("mainWindow", "Upload CSV"))
        # self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("mainWindow", " Plots"))
        # self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("mainWindow", "Page"))


   ##==========Attaching the functions to the buttons when clicked===========================================
        self.uploadFilesbutton.clicked.connect(self.selectDirectory)
        self.showUploadedFilesButton.clicked.connect(self.showUploadedFilesFunction)
        self.dataCounts.clicked.connect(self.getdataCounts)
        self.reviewPatches.clicked.connect(self.reviewPatches_Function)
        self.breastTissuePatches.clicked.connect(self.breastTissuePatches_Function)
        self.visualizeBinary.clicked.connect(self.visualizeBreastTissueSliceBinary_Function)
        self.visualizeBreastTissue.clicked.connect(self.visualizeBreastTissueImages_Function)
        self.ViewDatasets.clicked.connect(self.targetdistributions_Function)
        self.createDatasetButton.clicked.connect(self.createDatasets)
        self.HighLRButton.clicked.connect(self.searchingOptimalCyclical_HIGH_lr_Function)
        self.LowLRButton.clicked.connect(self.searchingOptimalCyclical_LOW_lr_Function)
        self.lossConvergenceButton.clicked.connect(self.lossConvergence_Function)
        self.idcprobabilityMap_button.clicked.connect(self.IDClandscape_Function)
        self.validationDataSet_Button.clicked.connect(self.validationPredictions)
        self.viewAllpatients_probabilityButton.clicked.connect(self.viewAllpatientsProbabilityResult_Function)
        self.validationConfusionMatrix_Button.clicked.connect(self.AUC_score_ConfusionMatrix_Function)
        self.predictionResult.clicked.connect(self.exportPredictionResult_Function)
        self.searchPatientID.returnPressed.connect(self.searchPatient_Function)
        self.negative_Checkbox.stateChanged.connect(self.CheckBox_Function)
        self.positive_Checkbox.stateChanged.connect(self.CheckBox_Function)
        



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    mainWindow = QtWidgets.QWidget()
    ui = Main()
    ui.setupUi(mainWindow)
    mainWindow.show()
    sys.exit(app.exec_())


#=============================================================================

